<?xml version="1.0" encoding="UTF-8"?>
<html>
<body>
    <title>טיפול בקבצים</title>
    <section>הכוונת קלט\פלט</section>
    <text>
אחת הדרכים הקלות לטפל בקבצים, זה להזין אותם לתוכנית דרך הקלט\פלט הסטנדרטי. התוכנית תקרא את הקלט כאילו המשתמש כתב אותו, בעזרת האופרטור &lt;&gt;, ותוציא את הפלט בעזרת print רגיל, שינותב לקובץ אחר. דוגמא להרצת תוכנית כזו:
    </text>
    <code>
./myprog.pl &lt;inFile &gt;outFile
    </code>
    <text>
התוכנית תקבל את הקלט מתוך הקובץ inFile, ותוציא את הפלט לקובץ outFile. והיופי בזה, שהתוכנית בכלל לא יודע שהיא עושה את זה. מבחינתה, היא מקבלת הקלדות מהמשתמש, ומוציאה לו על המסך מידע.<br/>
אתה יכול לקחת את תוכנית הדוגמא שבסוף הפרק, להוריד את כל הוראות פתיחת וסגירת הקבצים, ופשוט לחתוך את המילים "InFile" ו-"OutFile". ואם נקרא לתוכנית LinkProcess.pl, אזי אפשר להריץ:
    </text>
    <code>
./LinkProcess.pl  &lt; urls.txt  &gt; urls.html
    </code>
    <section>משתנה מטיפוס קובץ</section>
    <text>
    הכר את טיפוס הנתונים הרביעי של פרל: קובץ (File Handler). לטיפוס זה אין שום סימן לפניו, ובאופן מסורתי המשתנים נכתבים עם אותיות גדולות. כמו כן, סוג משתנה זה אינו דורש הגדרה, אלא אפשר פשוט להתחיל להשתמש בו, כאילו אין strict.<br/>
    לפתיחת קובץ משתמשים בפקודת open. (מפתיע, אך אמיתי) אפשר לפתוח קובץ לקריאה ולכתיבה. ככה:
    </text>
    <code>
open(FH, "> wwwest.txt");
    </code>
    <text>
עכשיו תשכח ממנו. למה? כי מה פתאום יש לנו משתנה שלא הגדרנו? ועוד הוא גלובלי, כלומר אם תשתמש באותו שם משתנה בפונקציות אחרות, אתה דורס את המשתנה הקודם. ואם אתה מאלה שכותבים פונקציות רקורסיביות, אז בכלל אי אפשר להשתמש בזה.<br/>
אני גם מבקש שתשכח שאפשר לכתוב open עם שני פרמטרים. אין שום סיבה להשתמש בזה היום, אלא רק בצורות עם שלושה פרמטרים. אם אתה רואה open עם שניים, אוטומטית תחליף לשלושה, כמו שתראה בסעיפון הבא.
    </text>
    <section>פתיחת קובץ</section>
    <text>
אז הנה, ככה פותחים קובץ:
    </text>
    <code>
open(my $fh, ">", "wwwest.txt"); 
    </code>
    <text>
הפקודה הזאת פותחת את הקובץ wwwest.txt לכתיבה. אם הקובץ לא קיים, הוא נוצר.<br/>
שים לב שהגדרנו את <code>$fh</code> בעזרת פקודת my, ולכן הוא משתנה מקומי כמו כל משתנה אחר.<br/>
בד"כ מוסיפים לפקודת open גם פקודת die:
    </text>
    <code>
open(my $fh, ">", "wwwest.txt") or die "Cann't open wwwest.txt!\n"; 
    </code>
    <text>
פקודת die היא ההתראה (Exception) של פרל. בניגוד לפקודת exit (שגם קיימת) שפשוט מפסיקה את הרצת התוכנית, die מוציאה הודעת שגיאה מסודרת, וסוגרת את התוכנית. אפשר לתפוס את סגירת התוכנית, ולהמשיך אותה בכל זאת, אבל זה סיפור אחר.<br/>
בכל מקרה, הפקודה שלמעלה מנסה לפתוח\ליצור את הקובץ לכתיבה. אם היא מצליחה, היא מחזירה אמת, ואין צורך להתקדם לפקודה הבאה. אם היא לא מצליחה, היא מחזירה שקר, ואז פקודת die פועלת ומפסיקה את ההרצה.<br/>
פתיחת קובץ לקריאה:
    </text>
    <code>
open(my $fh, "&lt;", "wwwest.txt") or die "Can't open wwwest.txt!\n"; 
    </code>
    <text>
פתיחת הקובץ להוספה (Append):
    </text>
    <code>
open(my $fh, ">>", "wwwest.txt") or die "Can't open wwwest.txt!\n"; 
    </code>
    <section>אופרטור &lt;&gt;</section>
    <text>
הזכרתי את האופרטור הזה בעבר. מה שהוא עושה, זה לקרוא מקובץ שורה. ככה:
    </text>
    <code>
$line = &lt;$fh&gt;;
    </code>
    <text>
אם לא כתוב מחזיק-קובץ בין סימני הגדול-קטן, אזי הוא קורא מתוך ה-stdin, שזה הקלט הסטנדרטי. זה יכול להיות מהמקלדת, או מקובץ, תלוי איך מריצים את הקובץ. הנה דוגמא טיפוסית לקוד:
    </text>
    <code>
my %config;
while (my $line = &lt;$fh&gt;) { 
    chomp $line; 
    next if ($line =~ m/^#/); # skip comments
    my ($key, $value) = split '=', $line;
    $config{$key} = $value;
    print "Got config: $key=$value\n";
} 
    </code>
    <text>
פקודת ה-while מפעילה את אופרטור ה-&lt;&gt;, שקורא שורה מתוך מחזיק קובץ <code>$fh</code> שככל הנראה פתחנו קודם לקריאה, ומכניס את השורה (כולל סימן סוף השורה) לתוך המשתנה <code>$line</code>. כל עוד שיש מה לקרוא מהקובץ, המשתנה הוא אמת, ולולאת ה-while ממשיכה לרוץ.<br/>
שורה שניה - עושה chomp ל-<code>$line</code> - מה שמוריד את סימן סוף השורה מהמשתנה. כי הוא בד"כ לא באמת מעניין אותנו.<br/>
שורה שלישית - בודקת האם הקלט מתחיל בסימן '#'. אם כן - זוהי שורת הערה ומדלגים לשורה הבאה.<br/>
אנחנו יודעים שבקובץ יש שורות של פרמטרים, בפורמט של מפתח=ערך. אז שוברים את השורה לשניים לפי ה-"=". הראשון מפתח, השני ערך, ואנחנו מכניסים את שניהם להאש כלשהו. בתקווה שגם נעשה עם ההאש העם ההאש הזה משהו אח"כ.<br/>
אם תריץ את האופרטור &lt;&gt; בהקשר רשימה, אז הוא יקרא את כל השורות, ולא רק אחת.
    </text>
    <code>
my @lines; 
@lines=&lt;&gt;; 
    </code>
    <text>
אחרי זה, כל שורות הקלט יהיו בתוך המערך <code>@lines</code>.
    </text>
    <section>כתיבה לקובץ</section>
    <text>
פה אין הרבה הפתעות - בשביל לכתוב לקובץ משתמשים בפקודה print. כמו שעד עכשיו כתבנו לתוך הפלט הסטנדרטי, ככה נכתוב לכל קובץ פתוח אחר:
    </text>
    <code>
open(my $fh, ">", "tmp.txt") or die "AHHHHH!\n"; 
print $fh "The time is: " , scalar(localtime()), "\n"; 
    </code>
    <text>
שים לב שאין פסיק בין FH לבין המחרוזת הראשונה. ככה זה. (ואם תשים פסיק, זו תהיה טעות. פקודת ה-print תנסה להדפיס את מחזיק הקובץ. דווקא חוסר הפסיק אומר לו שפה יש מחזיק קובץ, ולא משהו להדפסה)
    </text>
    <section>סגירת קובץ</section>
    <text>
בצורה מפתיעה ביותר, בשביל לסגור קובץ משתמשים בפקודת close.
    </text>
    <code>
close($fh); 
    </code>
    <section>אבל הקובץ שלי הוא</section>
    <text>
אבל הקובץ שלי הוא לא סתם שורות! הוא &lt;הכנס כאן פורמט זה או אחר&gt;!<br/>
ובכן, אם זה פורמט מוכר, רוב הסיכויים שיש כבר מודול ב-CPAN שמטפל בו. הצץ בפרק 7 להסברים על חיפוש והתקנת מודולים משם.<br/>
אם זה קובץ בינארי לא מוכר, ואין מודול שיעשה לך את העבודה, תצטרך להשתמש בפקודות binmode, read, write לקרוא ולכתוב מהקובץ הזה.
הנה דוגמא של תוכנית קטנה שעוברת על קובץ בינארי ועושה checksum עליו:
    </text>
    <code>
open my $fh, "&lt; :raw", "binfile.dat" or die "can not open file";
my $buf = '';
my $checksum = 0;
while (read( $fh, $buf, 100 )) {
    my @numbers = unpack "C*", $buf;
    for my $t (@numbers) {
        $checksum = ( $checksum + $t ) % 256;
    }    
}
print "File Checksum is $checksum\n"; 
    </code>
    <section>תוכנית דוגמא</section>
    <code>
#!/usr/bin/perl -w 
use strict; 

open(my $InFile, "&lt;", "urls.txt") or die "Error IN!\n"; 
open(my $OutFile, ">", "urls.html") or die "Error OUT\n"; 

print $OutFile "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;"; 
print $OutFile "Semuel's Link Page"; 
print $OutFile "&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;"; 

while(my $line = &lt;$InFile&gt;){ 
    chomp $line; 
    if ($line=~m/^http/i) { 
        print $OutFile "&lt;A HREF= $line &gt; $line &lt;/A&gt;&lt;br&gt;\n"; 
    } else { 
        print $OutFile "$line &lt;br&gt;\n"; 
    } 
} 

print $OutFile"&lt;/BODY&gt;&lt;/HTML&gt;"; 

close($InFile); 
close($OutFile);
    </code>
    <text>
התוכנית קוראת מקובץ טקסט המכיל רשימת לינקים, וכותבת קובץ html המכיל את אותה הרשימה, רק שעכשיו הלינקים הם באמת לינקים, (השורות שהם לא לינק עוברות דרך התוכנית, ואפילו מקבלות תג של סוף שורה בסופן) ואפשר להשתמש בקובץ דרך גלשן אינטרנט. (זה למעשה תוכנית ישנה שפעם עבדתי איתה. היה לי קובץ טקסט מסכן שם זרקתי את כל הלינקים שרציתי לשמור, והתוכנית הזאת הפכה את קובץ הטקסט למשהו שמיש)
    </text>
</body>
</html>